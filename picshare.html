<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>問診票画像（Noto優先 / なければ自動Webフォント）</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="color-scheme" content="light dark" />
<style>
  :root{
    /* JPフォントを最優先。Android/ChromeOS向けに Noto Sans CJK JP も併記 */
    --jp-font: "Noto Sans JP","Noto Sans CJK JP","Hiragino Sans","Hiragino Kaku Gothic ProN","Yu Gothic",Meiryo,system-ui,sans-serif;

    --bg:#0e1116; --fg:#e7eaee; --muted:#97a1ad; --border:#2b3138; --accent:#2f81f7; --accent-press:#1f6fe0;
    --radius:12px; --space:clamp(14px,3.6vw,22px); --maxw:780px;
  }
  @media (prefers-color-scheme: light){
    :root{ --bg:#f6f7f9; --fg:#0f1720; --muted:#5b6776; --border:#e5e7eb; }
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{
    margin:0; color:var(--fg); background:var(--bg);
    font-family: var(--jp-font);
    -webkit-font-smoothing:antialiased; line-height:1.6;
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
  }
  .wrap{max-width:var(--maxw); margin:0 auto; padding:var(--space)}
  header h1{ margin:0 0 6px; font-size:clamp(20px,5.4vw,28px) }
  header p{ margin:0 0 var(--space); color:var(--muted); font-size:.95rem }

  .section-title{ margin:22px 0 10px; font-weight:800; font-size:clamp(16px,4.4vw,20px) }
  .grid{ display:grid; grid-template-columns:1fr; gap:12px }
  .row2{ display:grid; grid-template-columns:1fr 1fr; gap:12px }
  @media (max-width:560px){ .row2{ grid-template-columns:1fr } }

  label.title{ display:block; color:var(--muted); font-size:.92rem; margin:0 0 6px }
  textarea, input[type="text"]{
    width:100%; border:1px solid var(--border); background:transparent; color:var(--fg);
    border-radius:10px; font-size:16px; padding:11px 12px; outline:none; font-family: var(--jp-font);
  }
  textarea:focus, input[type="text"]:focus{ border-color:var(--accent); box-shadow:0 0 0 3px color-mix(in oklab, var(--accent) 22%, transparent) }

  .choices{ display:flex; flex-wrap:wrap; gap:8px }
  .chip{ display:inline-flex; align-items:center; gap:6px; border:1px solid var(--border);
    padding:8px 10px; border-radius:999px; user-select:none; font-size:14px; background:transparent; cursor:pointer; font-family: var(--jp-font);
  }
  .chip input{ appearance:none; width:18px; height:18px; border:2px solid var(--muted); border-radius:4px; display:inline-block; position:relative; margin-right:2px }
  .chip input:checked{ border-color:var(--accent); background:var(--accent) }
  .chip input:checked::after{ content:""; position:absolute; inset:2px; background:#fff; border-radius:2px }
  .chip--radio input{ border-radius:50% }

  .btnrow{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin:16px 0 0 }
  @media (max-width:560px){ .btnrow{ grid-template-columns:1fr } }
  .btn{
    -webkit-tap-highlight-color:transparent; user-select:none; appearance:none; border:0;
    border-radius:12px; font-size:16px; font-weight:700; padding:14px 16px; cursor:pointer;
    transition:transform .04s ease, box-shadow .2s ease, background .2s ease, opacity .2s ease;
    box-shadow:0 6px 18px rgba(0,0,0,.12); font-family: var(--jp-font);
  }
  .btn:active{ transform:translateY(1px) scale(.99) }
  .btn--primary{ color:#fff; background:linear-gradient(180deg, var(--accent), color-mix(in oklab, var(--accent) 88%, black)) }
  .btn--primary:active{ background:linear-gradient(180deg, var(--accent-press), color-mix(in oklab, var(--accent-press) 80%, black)) }
  .btn--ghost{ background:transparent; color:var(--fg); border:1px solid var(--border) }
  .btn[disabled]{ opacity:.55; cursor:not-allowed; box-shadow:none }

  .preview{ margin:28px 0 0 }
  .preview h2{ margin:0 0 10px; font-size:clamp(18px,4.8vw,22px) }
  .canvas-wrap{ border:1px solid var(--border); border-radius:var(--radius); overflow:hidden; background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.06)) }
  .canvas-inner{ aspect-ratio:3/4 }
  canvas{ width:100%; height:100%; display:block }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>問診票画像（Noto優先 / 無ければ自動Webフォント）</h1>
      <p>ローカルの <strong>Noto Sans JP</strong> を最優先で使用。無い場合は自動で Google Fonts を読み込み、フォントロード後に Canvas を再描画します。</p>
    </header>

    <!-- フォーム自動生成 -->
    <section id="form-root"></section>

    <!-- アクション -->
    <div class="btnrow">
      <button id="btn-save" class="btn btn--ghost" type="button">PNG保存</button>
      <button id="btn-share" class="btn btn--primary" type="button">Twitter等に共有（Web Share）</button>
    </div>

    <!-- プレビュー（最下部） -->
    <section class="preview">
      <h2>プレビュー（自動更新 / 3:4）</h2>
      <div class="canvas-wrap"><div class="canvas-inner">
        <canvas id="cv" width="900" height="1200" aria-label="問診票画像プレビュー"></canvas>
      </div></div>
    </section>
  </div>

<script>
  // ==================== CONFIG（UI/描画/フォント一元管理） ====================
  const CONFIG = {
    font: {
      family: `"Noto Sans JP","Noto Sans CJK JP","Hiragino Sans","Hiragino Kaku Gothic ProN","Yu Gothic",Meiryo,system-ui,sans-serif`,
      // Canvasで使う代表サイズ・ウェイトをロードに使う
      toLoad: [
        { weight: 500, size: 20 },
        { weight: 600, size: 20 },
        { weight: 700, size: 20 },
        { weight: 800, size: 24 }
      ]
    },
    canvas: {
      paper: {
        inset: 24, radius: 16, borderColor: "#e6e8ec", borderWidth: 2,
        shadow: { offsetX: 10, offsetY: 12, blur: 28, color: "rgba(0,0,0,0.14)" },
        toneTop: "rgba(0,0,0,0.03)", toneBottom: "rgba(0,0,0,0.02)"
      },
      padding: 60
    },
    header: {
      title: { text: "問診票", x: 60, y: 120, bar: { w: 10, h: 36, color: "#2f81f7" }, font: { size: 24, weight: 800, color: "#0f1720" } },
      date:  { show:true, xRight: 60, font:{ size:20, weight:600, color:"#0f1720" } },
      basicsLineY: 220, basicsLineColor: "rgba(0,0,0,0.12)", basicsLineWidth: 2
    },
    sections: [
      {
        title: "基本情報",
        fields: [
          { id:"name",  kind:"text", label:"氏名", default:"",
            layout:{ type:"pair", xLabel:60, xValue:180, y:200,
                     font:{ labelSize:20, valueSize:20, labelWeight:600, valueWeight:500, color:"#0f1720" },
                     fallback:"（未入力）" }
          },
          { id:"age",   kind:"text", label:"年齢", default:"" },
          { id:"sex",   kind:"radio", label:"性別（単一選択）",
            options:["男性","女性","その他","無回答"], default:"無回答",
            layout:{ type:"pair-computed",
                     xLabel:60+Math.round(700*0.52), xValue:60+Math.round(700*0.52)+120, y:200,
                     font:{ labelSize:20, valueSize:20, labelWeight:600, valueWeight:500, color:"#0f1720" },
                     labelText:"年齢 / 性別",
                     compute: (vals)=>`${vals.age||'—'} ／ ${vals.sex||'—'}` }
          },
        ]
      },
      {
        title: "主訴",
        fields: [
          { id:"chief", kind:"checkbox", label:"主訴",
            options:["発熱","咳","喉の痛み","鼻水","頭痛","吐き気","腹痛","倦怠感","関節痛"],
            default:["発熱","喉の痛み"],
            layout:{ type:"checkbox-list",
                     title:{text:"主訴", x:60, y:260, bar:{w:6,h:18,color:"#2f81f7"}, font:{size:20,weight:800,color:"#0f1720"}},
                     x:68, y:295, boxSize:20, textSize:20, lineGap:14,
                     color:{ box:"rgba(0,0,0,0.35)", fill:"#2f81f7", check:"#fff", text:"#0f1720" } }
          }
        ]
      },
      {
        title: "発症時期・体温",
        fields: [
          { id:"onset", kind:"radio", label:"発症時期", options:["本日","昨日","2〜3日前","1週間以上前"], default:"本日",
            layout:{ type:"radio-list",
                     title:{text:"発症時期・体温", x:60, y:585, bar:{w:6,h:18,color:"#2f81f7"}, font:{size:20,weight:800,color:"#0f1720"}},
                     x:68, y:610, radius:10, textSize:20, lineGap:14,
                     color:{ ring:"rgba(0,0,0,0.35)", dot:"#2f81f7", text:"#0f1720" },
                     tempRight:{ id:"temp", label:"体温", xRel:0.55,
                                 fontLabel:{ size:20, weight:700 }, fontValue:{ size:20, weight:500 } } }
          },
          { id:"temp", kind:"text", label:"体温（任意）", default:"" }
        ]
      },
      {
        title: "既往歴",
        fields: [
          { id:"pmh", kind:"checkbox", label:"既往歴",
            options:["高血圧","糖尿病","心疾患","喘息","花粉症","特記なし"], default:["特記なし"],
            layout:{ type:"checkbox-list",
                     title:{text:"既往歴", x:60, y:760, bar:{w:6,h:18,color:"#2f81f7"}, font:{size:20,weight:800,color:"#0f1720"}},
                     x:68, y:795, boxSize:20, textSize:20, lineGap:14,
                     color:{ box:"rgba(0,0,0,0.35)", fill:"#2f81f7", check:"#fff", text:"#0f1720" } }
          }
        ]
      },
      {
        title: "服薬・アレルギー",
        fields: [
          { id:"meds", kind:"text", label:"服用中の薬（任意）", default:"",
            layout:{ type:"inline-label", label:"服用中の薬", xLabel:68, xValue:68+140, y:1020,
                     fontLabel:{size:20,weight:700}, fontValue:{size:20,weight:500} }
          },
          { id:"allergy", kind:"text", label:"アレルギー（任意）", default:"",
            layout:{ type:"inline-label", label:"アレルギー", xLabel:68, xValue:68+140, y:1060,
                     fontLabel:{size:20,weight:700}, fontValue:{size:20,weight:500} }
          }
        ]
      },
      {
        title: "症状の詳細（自由記入）",
        fields: [
          { id:"detail", kind:"textarea", label:"症状の詳細（自由記入）", default:"",
            layout:{ type:"textarea-box",
                     title:{text:"症状の詳細（自由記入）", x:60, y:1120, bar:{w:6,h:18,color:"#2f81f7"}, font:{size:20,weight:800,color:"#0f1720"}},
                     x:68, y:1155, wRel:1.0, hRel:0.18, radius:10,
                     font:{size:20,weight:500,color:"#0f1720"}, lines:7 }
          }
        ]
      }
    ]
  };

  // ============ UI生成（CONFIG→HTML） ============
  const formRoot = document.getElementById('form-root');
  function renderFormFromConfig() {
    formRoot.innerHTML = "";
    CONFIG.sections.forEach(sec => {
      const secTitle = document.createElement('div');
      secTitle.className = 'section-title';
      secTitle.textContent = sec.title;
      formRoot.appendChild(secTitle);

      const container = document.createElement('div');
      container.className = sec.title.includes('基本情報') || sec.title.includes('服薬') ? 'grid row2' : 'grid';
      formRoot.appendChild(container);

      sec.fields.forEach(field => {
        if (field.kind === 'computed') return;
        const wrap = document.createElement('div');

        if (field.kind === 'text' || field.kind === 'textarea') {
          const label = document.createElement('label');
          label.className = 'title';
          label.setAttribute('for', field.id);
          label.textContent = field.label;
          const input = field.kind === 'text'
            ? Object.assign(document.createElement('input'), { id:field.id, type:'text', value:field.default||'', placeholder: field.placeholder || '' })
            : Object.assign(document.createElement('textarea'), { id:field.id, rows:4, value:field.default||'', placeholder: field.placeholder || '' });
          wrap.appendChild(label); wrap.appendChild(input);

        } else if (field.kind === 'radio' || field.kind === 'checkbox') {
          const label = document.createElement('label');
          label.className = 'title';
          label.textContent = field.label;
          const choices = document.createElement('div');
          choices.className = 'choices';
          field.options.forEach(opt => {
            const chip = document.createElement('label');
            chip.className = 'chip' + (field.kind==='radio' ? ' chip--radio':'');
            const input = document.createElement('input');
            input.type = field.kind;
            input.name = field.id;
            input.value = opt;
            if (field.kind==='radio' && (field.default ?? field.options[0]) === opt) input.checked = true;
            if (field.kind==='checkbox' && Array.isArray(field.default) && field.default.includes(opt)) input.checked = true;
            chip.appendChild(input);
            chip.appendChild(document.createTextNode(opt));
            choices.appendChild(chip);
          });
          wrap.appendChild(label); wrap.appendChild(choices);
        }
        container.appendChild(wrap);
      });
    });
  }

  // ============ 値取得 ============
  function getValues() {
    const vals = {};
    CONFIG.sections.flatMap(s => s.fields).forEach(f => {
      if (f.kind === 'text' || f.kind === 'textarea') {
        vals[f.id] = (document.getElementById(f.id)?.value || "").trim();
      } else if (f.kind === 'radio') {
        const el = document.querySelector(`input[name="${f.id}"]:checked`);
        vals[f.id] = el ? el.value : "";
      } else if (f.kind === 'checkbox') {
        vals[f.id] = Array.from(document.querySelectorAll(`input[name="${f.id}"]:checked`)).map(i => i.value);
      }
    });
    return vals;
  }

  // ============ Canvas描画 ============
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const JP_FAMILY = CONFIG.font.family; // まとめて使う

  function fitCanvasToDisplaySize(canvas) {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const { width: cssW, height: cssH } = canvas.getBoundingClientRect();
    const displayW = Math.round(cssW * dpr);
    const displayH = Math.round(cssH * dpr);
    if (canvas.width !== displayW || canvas.height !== displayH) {
      canvas.width = displayW; canvas.height = displayH; return true;
    }
    return false;
  }
  function rr(x,y,w,h,r){ const rad=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+rad,y); ctx.arcTo(x+w,y,x+w,y+h,rad); ctx.arcTo(x+w,y+h,x,y+h,rad); ctx.arcTo(x,y+h,x,y,rad); ctx.arcTo(x,y,x+w,y,rad); ctx.closePath(); }

  // 紙（白＋薄枠＋右下グロー）
  function drawPaper() {
    const p = CONFIG.canvas.paper;
    const x = p.inset, y = p.inset, w = cv.width - p.inset*2, h = cv.height - p.inset*2;

    ctx.save();
    ctx.shadowColor = p.shadow.color;
    ctx.shadowBlur = p.shadow.blur;
    ctx.shadowOffsetX = p.shadow.offsetX;
    ctx.shadowOffsetY = p.shadow.offsetY;
    rr(x, y, w, h, p.radius);
    ctx.fillStyle = "#ffffff";
    ctx.fill();
    ctx.restore();

    // 紙トーン（上:うっすら暗、下:うっすら明）
    const topGrad = ctx.createLinearGradient(0, y, 0, y + Math.min(80, h*0.08));
    topGrad.addColorStop(0, p.toneTop);
    topGrad.addColorStop(1, "rgba(255,255,255,0)");
    ctx.save(); rr(x, y, w, h, p.radius); ctx.clip();
    ctx.fillStyle = topGrad; ctx.fillRect(x, y, w, Math.min(80, h*0.08));
    const botGrad = ctx.createLinearGradient(0, y+h - Math.min(100, h*0.1), 0, y+h);
    botGrad.addColorStop(0, "rgba(255,255,255,0)");
    botGrad.addColorStop(1, p.toneBottom);
    ctx.fillStyle = botGrad; ctx.fillRect(x, y+h - Math.min(100, h*0.1), w, Math.min(100, h*0.1));
    ctx.restore();

    // 枠線
    ctx.strokeStyle = p.borderColor; ctx.lineWidth = p.borderWidth;
    rr(x, y, w, h, p.radius); ctx.stroke();
  }

  function findField(id){ return CONFIG.sections.flatMap(s=>s.fields).find(f=>f.id===id) }

  function drawTitleArea(vals) {
    const {title,date,basicsLineY,basicsLineColor,basicsLineWidth} = CONFIG.header;
    ctx.fillStyle = title.bar.color; ctx.fillRect(title.x, title.y - title.bar.h + 2, title.bar.w, title.bar.h);
    ctx.fillStyle = title.font.color; ctx.font = `${title.font.weight} ${title.font.size}px ${JP_FAMILY}`;
    ctx.fillText(title.text, title.x + title.bar.w + 12, title.y);
    if (date?.show){
      const ts = new Date().toLocaleString('ja-JP', {year:'numeric',month:'2-digit',day:'2-digit'});
      const tw = ctx.measureText(ts).width;
      ctx.font = `${date.font.weight} ${date.font.size}px ${JP_FAMILY}`;
      ctx.fillStyle = date.font.color;
      ctx.fillText(ts, cv.width - CONFIG.canvas.paper.inset - date.xRight - tw + date.xRight, title.y);
    }
    ctx.strokeStyle = basicsLineColor; ctx.lineWidth = basicsLineWidth;
    ctx.beginPath();
    ctx.moveTo(CONFIG.canvas.paper.inset + 36, basicsLineY);
    ctx.lineTo(cv.width - CONFIG.canvas.paper.inset - 36, basicsLineY);
    ctx.stroke();

    const nameField = findField('name'); const pair = nameField.layout;
    ctx.fillStyle = pair.font.color;
    ctx.font = `${pair.font.labelWeight} ${pair.font.labelSize}px ${JP_FAMILY}`;
    ctx.fillText('氏名', pair.xLabel, pair.y);
    ctx.font = `${pair.font.valueWeight} ${pair.font.valueSize}px ${JP_FAMILY}`;
    ctx.fillText(vals.name || pair.fallback || '（未入力）', pair.xValue, pair.y);

    const sexField = findField('sex'); const r = sexField.layout;
    ctx.fillStyle = r.font.color;
    ctx.font = `${r.font.labelWeight} ${r.font.labelSize}px ${JP_FAMILY}`;
    ctx.fillText(r.labelText, r.xLabel, r.y);
    ctx.font = `${r.font.valueWeight} ${r.font.valueSize}px ${JP_FAMILY}`;
    const computed = r.compute ? r.compute(vals) : '';
    ctx.fillText(computed, r.xValue, r.y);
  }

  function drawCheckboxList(lay, labels, checkedSet){
    let y = lay.y;
    const lineH = Math.max(lay.boxSize * 1.2, lay.textSize * 1.3);
    if (lay.title){
      ctx.fillStyle = lay.title.font.color;
      ctx.fillRect(lay.title.x, lay.title.y - lay.title.bar.h + 2, lay.title.bar.w, lay.title.bar.h);
      ctx.font = `${lay.title.font.weight} ${lay.title.font.size}px ${JP_FAMILY}`;
      ctx.fillText(lay.title.text, lay.title.x + lay.title.bar.w + 12, lay.title.y);
    }
    labels.forEach(lb=>{
      ctx.strokeStyle = lay.color.box; ctx.lineWidth = 2;
      ctx.strokeRect(lay.x, y - lay.boxSize + 4, lay.boxSize, lay.boxSize);
      if (checkedSet.has(lb)){
        ctx.fillStyle = lay.color.fill; ctx.fillRect(lay.x, y - lay.boxSize + 4, lay.boxSize, lay.boxSize);
        ctx.fillStyle = lay.color.check; ctx.font = `700 ${Math.round(lay.boxSize*0.8)}px ${JP_FAMILY}`;
        ctx.fillText('✓', lay.x + 2, y + Math.round(lay.boxSize*0.2));
      }
      ctx.fillStyle = lay.color.text; ctx.font = `500 ${lay.textSize}px ${JP_FAMILY}`;
      ctx.fillText(lb, lay.x + lay.boxSize + 10, y + Math.round(lay.textSize*0.15));
      y += lineH + lay.lineGap*0.25;
    });
    return y;
  }

  function drawRadioList(lay, options, value){
    let y = lay.y;
    const lineH = Math.max(lay.radius*2.2, lay.textSize*1.3);
    if (lay.title){
      ctx.fillStyle = lay.title.font.color;
      ctx.fillRect(lay.title.x, lay.title.y - lay.title.bar.h + 2, lay.title.bar.w, lay.title.bar.h);
      ctx.font = `${lay.title.font.weight} ${lay.title.font.size}px ${JP_FAMILY}`;
      ctx.fillText(lay.title.text, lay.title.x + lay.title.bar.w + 12, lay.title.y);
    }
    options.forEach(lb=>{
      ctx.strokeStyle = lay.color.ring; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(lay.x + lay.radius, y - lay.radius + 4, lay.radius, 0, Math.PI*2); ctx.stroke();
      if (value === lb){
        ctx.fillStyle = lay.color.dot;
        ctx.beginPath(); ctx.arc(lay.x + lay.radius, y - lay.radius + 4, Math.round(lay.radius*0.6), 0, Math.PI*2); ctx.fill();
      }
      ctx.fillStyle = lay.color.text; ctx.font = `500 ${lay.textSize}px ${JP_FAMILY}`;
      ctx.fillText(lb, lay.x + lay.radius*2 + 10, y + Math.round(lay.textSize*0.15));
      y += lineH + lay.lineGap*0.25;
    });
    return y;
  }

  function drawTextareaBox(lay, text){
    const usableW = (cv.width - CONFIG.canvas.paper.inset*2);
    const innerW = Math.round(usableW * (lay.wRel || 1)) - 12;
    const h = Math.round(cv.height * (lay.hRel || 0.18));
    if (lay.title){
      ctx.fillStyle = lay.title.font.color;
      ctx.fillRect(lay.title.x, lay.title.y - lay.title.bar.h + 2, lay.title.bar.w, lay.title.bar.h);
      ctx.font = `${lay.title.font.weight} ${lay.title.font.size}px ${JP_FAMILY}`;
      ctx.fillText(lay.title.text, lay.title.x + lay.title.bar.w + 12, lay.title.y);
    }
    rr(lay.x, lay.y + 10, innerW, h, lay.radius||10);
    ctx.fillStyle = 'rgba(0,0,0,0.04)'; ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.stroke();

    ctx.fillStyle = lay.font.color;
    ctx.font = `${lay.font.weight} ${lay.font.size}px ${JP_FAMILY}`;
    const maxLines = lay.lines || 7;
    const linePx = Math.round(lay.font.size * 1.4);
    wrapAndDrawText(text || '—', lay.x + 12, lay.y + 22 + lay.font.size, innerW - 24, linePx, maxLines);
  }

  function wrapAndDrawText(text, x, y, maxW, linePx, maxLines){
    const chars = (text||'').split(''); let line='', lines=[];
    chars.forEach(ch=>{ const w = ctx.measureText(line + ch).width; if (w > maxW && line){ lines.push(line); line = ch; } else { line += ch; } });
    if (line) lines.push(line);
    lines.slice(0, maxLines).forEach((ln,i)=> ctx.fillText(ln, x, y + i*linePx));
    return y + Math.min(lines.length, maxLines)*linePx;
  }

  function drawSignature(vals){
    const lay = findField('signature').layout;
    const y = cv.height - Math.round(cv.height * lay.yRelFromBottom);
    ctx.fillStyle = '#0f1720';
    ctx.font = `${lay.fontLabel.weight} ${Math.round(cv.height * lay.fontLabel.sizeRel)}px ${JP_FAMILY}`;
    ctx.fillText('署名：', CONFIG.canvas.paper.inset + 10, y);
    ctx.font = `${lay.fontValue.weight} ${Math.round(cv.height * lay.fontValue.sizeRel)}px ${JP_FAMILY}`;
    ctx.fillText(vals.name || '（署名）', CONFIG.canvas.paper.inset + 120, y);
  }

  function drawFromConfig(){
    fitCanvasToDisplaySize(cv);
    ctx.clearRect(0,0,cv.width,cv.height);
    drawPaper();

    const vals = getValues();
    drawTitleArea(vals);

    { const f = findField('chief'); const lay = f.layout; const set = new Set(vals.chief||[]); drawCheckboxList(lay, f.options, set); }
    { const f = findField('onset'); const lay = f.layout; drawRadioList(lay, f.options, vals.onset);
      if (lay.tempRight && findField('temp')){
        const colW = cv.width - CONFIG.canvas.paper.inset*2;
        const xLabel = CONFIG.canvas.paper.inset + Math.round(colW * lay.tempRight.xRel);
        const yLabel = lay.title.y + Math.round(colW * 0.08);
        ctx.fillStyle = '#0f1720';
        ctx.font = `${lay.tempRight.fontLabel.weight} ${lay.tempRight.fontLabel.size}px ${JP_FAMILY}`;
        ctx.fillText(lay.tempRight.label, xLabel, yLabel);
        ctx.font = `${lay.tempRight.fontValue.weight} ${lay.tempRight.fontValue.size}px ${JP_FAMILY}`;
        ctx.fillText(vals.temp || '—', xLabel + 60, yLabel);
      }
    }
    { const f = findField('pmh'); const lay = f.layout; const set = new Set(vals.pmh||[]); drawCheckboxList(lay, f.options, set); }

    ['meds','allergy'].forEach(id=>{
      const f = findField(id); const lay = f.layout;
      ctx.fillStyle = '#0f1720';
      ctx.font = `${lay.fontLabel.weight} ${lay.fontLabel.size}px ${JP_FAMILY}`;
      ctx.fillText(lay.label, lay.xLabel, lay.y);
      ctx.font = `${lay.fontValue.weight} ${lay.fontValue.size}px ${JP_FAMILY}`;
      ctx.fillText(vals[id] || '—', lay.xValue, lay.y);
    });

    { const f = findField('detail'); drawTextareaBox(f.layout, vals.detail); }
    drawSignature(vals);
  }

  // ============ フォント（Noto優先／無ければWebフォント） ============
  async function ensureNotoAndRedrawIfNeeded() {
    // すでにローカルにあるか？（Noto Sans JP / Noto Sans CJK JP のどちらか）
    const hasLocalNoto =
      (document.fonts && document.fonts.check(`20px "Noto Sans JP"`)) ||
      (document.fonts && document.fonts.check(`20px "Noto Sans CJK JP"`));

    if (hasLocalNoto) return; // ローカル命中 → 何もしない

    // 無い場合は Google Fonts を動的読み込み（weights: 500/600/700/800）
    // preconnect
    if (!document.getElementById('noto-preconnect')) {
      const pre = document.createElement('link');
      pre.id = 'noto-preconnect';
      pre.rel = 'preconnect';
      pre.href = 'https://fonts.gstatic.com';
      pre.crossOrigin = 'anonymous';
      document.head.appendChild(pre);
    }
    // stylesheet
    if (!document.getElementById('noto-css')) {
      const link = document.createElement('link');
      link.id = 'noto-css';
      link.rel = 'stylesheet';
      link.href = 'https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@500;600;700;800&display=swap';
      document.head.appendChild(link);
    }

    try {
      // 代表的なウェイトをロード。失敗しても描画は続行（フォールバック表示のまま）。
      if (document.fonts && document.fonts.load) {
        await Promise.all(
          CONFIG.font.toLoad.map(f => document.fonts.load(`${f.weight} ${f.size}px "Noto Sans JP"`))
        );
        await document.fonts.ready;
      }
      // ロードできたら再描画
      requestAnimationFrame(drawFromConfig);
    } catch(e) {
      // ネットワーク等でロード不可でも無視（フォールバックのまま使える）
      console.warn('Noto Sans JP webfont load failed:', e);
    }
  }

  // ============ 即時反映 & 初期化 ============
  function wireLiveRedraw() {
    document.body.addEventListener('input', e=>{
      if (e.target.closest('input, textarea')) requestAnimationFrame(drawFromConfig);
    });
    document.body.addEventListener('change', e=>{
      if (e.target.closest('input, textarea')) requestAnimationFrame(drawFromConfig);
    });
    const ro = new ResizeObserver(()=>drawFromConfig());
    ro.observe(cv);
    window.addEventListener('orientationchange', ()=>setTimeout(drawFromConfig, 120));
  }

  // ============ 保存・共有 ============
  const btnSave = document.getElementById('btn-save');
  const btnShare = document.getElementById('btn-share');

  btnSave.addEventListener('click', async ()=>{
    const blob = await new Promise(r => cv.toBlob(r, 'image/png'));
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `問診票_${Date.now()}.png`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });

  function canUseShareWithFiles(){
    if (!('share' in navigator)) return false;
    try { const t = new File(["x"], "x.txt", {type:"text/plain"}); return typeof navigator.canShare!=='function' || navigator.canShare({files:[t]}); }
    catch { return false; }
  }
  if (!canUseShareWithFiles()){ btnShare.disabled = true; btnShare.textContent = '共有非対応のブラウザです（PNG保存→手動投稿）'; }

  btnShare.addEventListener('click', async ()=>{
    try{
      const blob = await new Promise(r => cv.toBlob(r, 'image/png'));
      const file = new File([blob], 'monshin.png', { type:'image/png' });
      await navigator.share({ text:'問診票画像', files:[file] });
    }catch(e){ if (e?.name==='AbortError') return; alert('共有に失敗しました: ' + (e?.message||e)); }
  }, { passive:true });

  // ============ 起動 ============
  renderFormFromConfig();
  // テキスト系の初期値適用
  CONFIG.sections.flatMap(s=>s.fields).forEach(f=>{
    if ((f.kind==='text' || f.kind==='textarea') && f.default!=null){
      const el = document.getElementById(f.id); if (el) el.value = f.default;
    }
  });
  wireLiveRedraw();
  drawFromConfig();              // まずは手元のフォントで描画
  ensureNotoAndRedrawIfNeeded(); // Notoが無ければ読み込み→ロード後に再描画
</script>
</body>
</html>
